# Requirements Document

## Introduction

本文档定义了真正的流式 TTS 播放功能修复需求。当前系统虽然使用了流式 API，但在实现上存在阻塞问题：后端等待所有音频块生成完成后才开始发送数据，导致用户需要等待数百秒才能听到声音。本需求旨在实现真正的流式播放，让用户在音频生成的同时就能开始收听。

## Glossary

- **True Streaming**: 真正的流式处理，指数据块一旦生成就立即传输，不等待所有数据生成完成
- **Blocking Collection**: 阻塞式收集，指先收集所有数据到内存，然后再统一处理的模式
- **Async Generator**: 异步生成器，Python 中用于实现真正流式处理的机制
- **SSE (Server-Sent Events)**: 服务器推送事件，用于实现服务器到客户端的实时数据流
- **Gemini TTS API**: Google Gemini 的文本转语音 API，支持流式音频生成
- **PCM Audio**: 脉冲编码调制音频格式，原始音频数据格式
- **Base64 Encoding**: Base64 编码，用于在 HTTP 传输中编码二进制音频数据
- **Audio Chunk**: 音频块，流式生成的单个音频数据片段
- **First Byte Latency**: 首字节延迟，从请求发出到收到第一个数据字节的时间

## Requirements

### Requirement 1

**User Story:** 作为用户，我希望在点击播放后能够在2-5秒内听到声音，而不是等待数百秒，以便获得流畅的使用体验。

#### Acceptance Criteria

1. WHEN a user clicks the play button THEN the system SHALL begin streaming audio within 2 seconds
2. WHEN the first audio chunk is generated by the API THEN the system SHALL immediately send it to the frontend without waiting for subsequent chunks
3. WHEN subsequent audio chunks are generated THEN the system SHALL send each chunk immediately upon receipt
4. WHEN all audio chunks have been sent THEN the system SHALL send a completion event
5. WHEN the user starts playback THEN the first byte latency SHALL be less than 5 seconds

### Requirement 2

**User Story:** 作为开发者，我希望后端使用真正的异步流式处理，以便充分利用 Gemini TTS API 的流式能力。

#### Acceptance Criteria

1. WHEN the Gemini TTS API returns a stream THEN the system SHALL process it as an async generator without collecting all chunks first
2. WHEN an audio chunk is received from the API THEN the system SHALL yield it immediately to the caller
3. WHEN processing the stream THEN the system SHALL NOT use `run_in_executor` to wrap synchronous collection loops
4. WHEN processing the stream THEN the system SHALL use async iteration to process chunks one by one
5. WHEN an error occurs during streaming THEN the system SHALL handle it gracefully and notify the user immediately

### Requirement 3

**User Story:** 作为用户，我希望能够看到音频生成的实时进度，以便了解还需要等待多久。

#### Acceptance Criteria

1. WHEN audio chunks are being generated THEN the system SHALL send progress events indicating the number of chunks received
2. WHEN each chunk is sent THEN the system SHALL include the chunk index in the event data
3. WHEN the stream is in progress THEN the frontend SHALL display a loading indicator showing progress
4. WHEN the estimated total duration is known THEN the system SHALL include it in progress events
5. WHEN the stream completes THEN the system SHALL send the final duration in the completion event

### Requirement 4

**User Story:** 作为开发者，我希望系统能够正确处理 Gemini TTS API 的流式响应格式，以便准确提取音频数据。

#### Acceptance Criteria

1. WHEN the API returns a stream chunk THEN the system SHALL check for the presence of `candidates` in the response
2. WHEN a candidate contains content parts THEN the system SHALL iterate through all parts to find audio data
3. WHEN a part contains `inline_data` THEN the system SHALL extract the audio data from `inline_data.data`
4. WHEN a chunk contains no audio data THEN the system SHALL skip it and continue processing
5. WHEN extracting audio data THEN the system SHALL encode it as Base64 before sending to the frontend

### Requirement 5

**User Story:** 作为系统管理员，我希望系统能够记录详细的流式处理日志，以便监控性能和排查问题。

#### Acceptance Criteria

1. WHEN the stream starts THEN the system SHALL log the start time and request parameters
2. WHEN each chunk is received THEN the system SHALL log the chunk index and size
3. WHEN each chunk is sent THEN the system SHALL log the send time and cumulative data size
4. WHEN the stream completes THEN the system SHALL log the total duration, chunk count, and total data size
5. WHEN an error occurs THEN the system SHALL log the error with full context including the chunk index where it occurred

### Requirement 6

**User Story:** 作为用户，我希望系统能够在网络不稳定时继续播放已接收的音频，以便获得更好的体验。

#### Acceptance Criteria

1. WHEN a network error occurs during streaming THEN the system SHALL continue playing already buffered audio
2. WHEN the connection is lost THEN the system SHALL attempt to reconnect with exponential backoff
3. WHEN reconnection succeeds THEN the system SHALL resume streaming from where it left off
4. WHEN reconnection fails after 3 attempts THEN the system SHALL notify the user and stop playback
5. WHEN partial audio has been received THEN the system SHALL allow the user to play what has been buffered

### Requirement 7

**User Story:** 作为开发者，我希望移除阻塞式的音频块收集逻辑，以便实现真正的流式处理。

#### Acceptance Criteria

1. WHEN processing the API stream THEN the system SHALL NOT create a list to collect all chunks before yielding
2. WHEN a chunk is received from the API THEN the system SHALL yield it immediately without appending to a collection
3. WHEN the stream processing function is called THEN it SHALL be an async generator function using `async for` and `yield`
4. WHEN the function completes THEN it SHALL have yielded chunks incrementally, not all at once
5. WHEN measuring memory usage THEN the system SHALL use constant memory regardless of audio length

### Requirement 8

**User Story:** 作为用户，我希望系统能够在生成长音频时保持响应，以便我可以随时暂停或停止。

#### Acceptance Criteria

1. WHEN generating audio longer than 60 seconds THEN the system SHALL remain responsive to user commands
2. WHEN a user clicks pause during generation THEN the system SHALL pause playback immediately
3. WHEN a user clicks stop during generation THEN the system SHALL cancel the stream and stop playback
4. WHEN the stream is cancelled THEN the system SHALL clean up resources and close the API connection
5. WHEN resuming after pause THEN the system SHALL continue from the paused position without re-generating audio

### Requirement 9

**User Story:** 作为开发者，我希望使用 Python 的 asyncio 原生支持来处理流式数据，以便代码更简洁和高效。

#### Acceptance Criteria

1. WHEN the Gemini SDK provides a synchronous stream THEN the system SHALL wrap it properly for async iteration
2. WHEN wrapping a sync stream THEN the system SHALL use `asyncio.to_thread` for each iteration step
3. WHEN processing chunks THEN the system SHALL use `async for` syntax to iterate over the stream
4. WHEN yielding chunks THEN the system SHALL use `yield` in an async generator function
5. WHEN the implementation is complete THEN it SHALL NOT use `run_in_executor` with a function that collects all chunks

### Requirement 10

**User Story:** 作为用户，我希望系统能够显示准确的缓冲进度，以便我知道有多少音频已经可以播放。

#### Acceptance Criteria

1. WHEN audio chunks are received THEN the system SHALL calculate the cumulative buffered duration
2. WHEN the buffered duration changes THEN the system SHALL send an update event to the frontend
3. WHEN displaying the progress bar THEN the frontend SHALL show both buffered and played portions
4. WHEN the buffer is sufficient THEN the system SHALL indicate that playback can begin
5. WHEN the buffer is depleting THEN the system SHALL indicate that more data is being loaded
